package com.jay.android.dispatcher.compiler.processor;

import com.google.auto.service.AutoService;
import com.jay.android.dispatcher.annotation.Dispatch;
import com.jay.android.dispatcher.common.DispatchItem;
import com.jay.android.dispatcher.compiler.utils.AptUtils;
import com.squareup.javapoet.ArrayTypeName;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import net.ltgt.gradle.incap.IncrementalAnnotationProcessor;

import org.jetbrains.annotations.NotNull;

import java.io.IOException;
import java.util.Map;
import java.util.Set;

import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;

import static com.jay.android.dispatcher.common.CommonConst.CLASS_OF_GENERATE_PREFIX;
import static com.jay.android.dispatcher.common.CommonConst.PACKAGE_OF_GENERATE_FILE;
import static com.jay.android.dispatcher.compiler.messager.Logger.error;
import static com.jay.android.dispatcher.compiler.messager.Logger.info;
import static com.jay.android.dispatcher.compiler.utils.AptConst.DISPATCH_ITEM_CANONICAL_NAME;
import static com.jay.android.dispatcher.compiler.utils.AptConst.IDISPATCH_GROUP;
import static com.jay.android.dispatcher.compiler.utils.AptConst.METHOD_LOAD_INTO;
import static com.jay.android.dispatcher.compiler.utils.AptConst.PARAM_LOADINTO;
import static com.jay.android.dispatcher.compiler.utils.AptConst.WARNING_TIPS;
import static javax.lang.model.element.Modifier.PUBLIC;
import static net.ltgt.gradle.incap.IncrementalAnnotationProcessorType.ISOLATING;

/**
 * Dispatch Processor
 *
 * @author jaydroid
 * @version 1.0
 * @date 7/8/21
 */
@AutoService(Processor.class)
@IncrementalAnnotationProcessor(ISOLATING)
public class DispatchProcessor extends BaseProcessor {

  @Override
  public void init(@NotNull ProcessingEnvironment processingEnv) {
    super.init(processingEnv); // init AptContext
    setElementsAnnotated(Dispatch.class);
  }

  @Override
  public boolean process(Set<? extends TypeElement> set, RoundEnvironment environment) {

    if (!AptUtils.AptContext.INSTANCE.isInitFinish()) {
      throw new IllegalStateException("You should call AptContext#init() to init Messager first");
    }

    if (set != null && !set.isEmpty()) {
      try {
        info("Found dispatchElements, start parse dispatch ... ");
        parseDispatch(getAnnotationElements(environment));
      } catch (Exception e) {
        error(e);
      }
      return true; // 是需要的注释类型，并且不会要求后续处理器处理它们
    }
    return false; // 注释类型是无人认领的，可能会要求后续处理器处理它们
  }

  private void parseDispatch(Set<? extends Element> dispatchElements) {
    if (dispatchElements != null && !dispatchElements.isEmpty()) {
      info("Found dispatchElements, size is " + dispatchElements.size());
      /*
      要生成的类文件
      //DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY JDISPATCHER
      public class JDispatcher$$Group_7bbce2811b731506f0287afb797637d4 implements IDispatchGroup {
          @Override
          public void loadInto(Map<String, DispatchItem> atlas) {
              atlas.put("com.jay.android.jdispatcher.DispatcherAppDemo", DispatchItem.build("com.jay.android.jdispatcher.DispatcherAppDemo", 16, 394, "com.jay.android.jdispatcher.DispatcherAppDemo", new String[] {} ,"DispatcherAppDemo"));
          }
      }
       */

      // 创建方法
      MethodSpec method = createMethodWithElements(dispatchElements);
      // 创建类
      TypeSpec clazz = createClassWithMethod(method, dispatchElements);
      // 写入文件
      writeClassToFile(clazz);

    }
  }

  /** 创建方法 */
  private MethodSpec createMethodWithElements(Set<? extends Element> dispatchElements) {

    // Map<String, DispatchItem>
    ParameterizedTypeName inputMapTypeOfGroup =
        ParameterizedTypeName.get(
            ClassName.get(Map.class),
            ClassName.get(String.class),
            ClassName.get(DispatchItem.class));
    // Map<String, RouteMeta> atlas
    ParameterSpec groupParamSpec =
        ParameterSpec.builder(inputMapTypeOfGroup, PARAM_LOADINTO).build();

    // @Override
    // public void loadInto(Map<String, DispatchItem> atlas) {}
    MethodSpec.Builder loadIntoMethodOfGroupBuilder =
        MethodSpec.methodBuilder(METHOD_LOAD_INTO)
            .addAnnotation(Override.class)
            .addModifiers(PUBLIC)
            .addParameter(groupParamSpec);

    for (Element element : dispatchElements) {
      Dispatch dispatch = element.getAnnotation(Dispatch.class);
      if (dispatch != null && element instanceof TypeElement) {
        TypeElement typeElement = (TypeElement) element;
        String className = typeElement.getQualifiedName().toString();
        String name = dispatch.name();
        if (name.isEmpty()) {
          name = className;
        }
        int priority = dispatch.priority();
        int dimension = dispatch.dimension();
        String description = dispatch.description();
        String[] dependencies = dispatch.dependencies();
        String formatDependencies =
            dependencies.length > 0 ? "{\"" + String.join("\",\"", dependencies) + "\"}" : "{}";
        ArrayTypeName stringArray = ArrayTypeName.of(String.class);
        TypeName dispatchItemCanonicalName = AptUtils.getTypeName(DISPATCH_ITEM_CANONICAL_NAME);
        // atlas.put("com.jay.android.jdispatcher.DispatcherAppDemo",
        // DispatchItem.build("com.jay.android.jdispatcher.DispatcherAppDemo", 16, 394,
        // "com.jay.android.jdispatcher.DispatcherAppDemo", new String[]{}, "DispatcherAppDemo"));
        // DispatchItem(name, priority, dimension, className, dependencies, description)
        loadIntoMethodOfGroupBuilder.addStatement(
            "atlas.put($S, $T.build($S, $L, $L, $S, new $T $L ,$S))",
            name,
            dispatchItemCanonicalName,
            name,
            priority,
            dimension,
            className,
            stringArray,
            formatDependencies,
            description);
      }
    }
    return loadIntoMethodOfGroupBuilder.build();
  }

  /** 创建类 */
  private TypeSpec createClassWithMethod(MethodSpec method, Set<? extends Element> elements) {
    String hash = null;
    for (Element element : elements) {
      info(">>> createClassWithMethod hash:" + element + " <<<");
      hash = AptUtils.getHash(element);
      info(">>> createClassWithMethod hash:" + hash + " <<<");
      if (hash != null) {
        break;
      }
    }
    // JDispatcher$$Group_e927bbfff210966577fd6c70d127fe70
    String groupFileName = CLASS_OF_GENERATE_PREFIX + hash;
    // com.jay.android.dispatcher.common.IDispatchGroup
    TypeElement type_IDispatchGroup = AptUtils.AptContext.elements.getTypeElement(IDISPATCH_GROUP);
    return TypeSpec.classBuilder(groupFileName)
        .addJavadoc(WARNING_TIPS)
        .addSuperinterface(ClassName.get(type_IDispatchGroup))
        .addModifiers(PUBLIC)
        .addMethod(method)
        .build();
  }

  /** 将一个创建好的类写入到文件中参与编译 */
  private void writeClassToFile(TypeSpec clazz) {
    JavaFile file = JavaFile.builder(PACKAGE_OF_GENERATE_FILE, clazz).build();
    try {
      file.writeTo(AptUtils.AptContext.filer);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }
}
